import blockchain;

option Byte32Opt (Byte32);
array Pubkey [byte; 20];
array Signature [byte; 65];

struct MerkleState {
    merkle_root: Byte32,
    count: Uint64,
}

table GlobalState {
    account: MerkleState,
    block: MerkleState,
    status: Status,
}

union Status {
    Running,
    Reverting,
}

// normal status
table Running {}
// layer2 chain is reverting
struct Reverting {
    next_block_number: Uint64,
    challenger_id: Uint32,
}

table Account {
    id: Uint32,
    pubkey: Pubkey,
    nonce: Uint32,
    code_hash: Byte32Opt,
}

table RawL2Transaction {
    from_id: Uint32,
    to_id: Uint32,
    nonce: Uint32,
    args: Bytes,
}

table L2Transaction {
    raw: RawL2Transaction,
    signature: Signature,
}

table RawL2Block {
    number: Uint64,
    aggregator_id: Uint32,
    prev_account: MerkleState,
    post_account: MerkleState,
    states: States,
    valid: byte,
}

table L2Block {
    raw: RawL2Block,
    signature: Signature,
}

vector States <State>;

// --- define states ---

union State {
    SubmitTransactions,
    Join,
    Leave,
    RevertChain,
}

table SubmitTransactions {
    tx_root: Byte32,
    tx_count: Uint32,
    account_root_list: Byte32Vec,
}

// TODO
table Join {
}

table Leave {
}

// Revert the chain, send reward to reverter
struct RevertChain {
    reverter_id: Uint32,
    invalid_block_number: Uint64,
    post_account: MerkleState,
}

// --- end of define states ---
