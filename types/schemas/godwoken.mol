import blockchain;

option Byte32Opt (Byte32);

array Byte20 [byte; 20];
array Signature [byte; 65];

struct MerkleState {
    merkle_root: Byte32,
    count: Uint64,
}

table GlobalState {
    account: MerkleState,
    block: MerkleState,
    status: Status,
}

union Status {
    Running,
    Reverting,
}

// normal status
table Running {}
// layer2 chain is reverting
struct Reverting {
    next_block_number: Uint64,
    challenger_id: Uint32,
}

struct Account {
    id: Uint32,
    nonce: Uint32,
    pubkey_hash: Byte20,
    code_hash: Byte32,
}

table RawL2Transaction {
    from_id: Uint32,
    to_id: Uint32,
    nonce: Uint32,
    args: Bytes,
}

table L2Transaction {
    raw: RawL2Transaction,
    signature: Signature,
}

table RawL2Block {
    number: Uint64,
    aggregator_id: Uint32,
    timestamp: Uint64,
    prev_account: MerkleState,
    post_account: MerkleState,
    states: States,
    valid: byte,
}

table L2Block {
    raw: RawL2Block,
    signature: Signature,
}

vector States <State>;

// --- define states ---

union State {
    SubmitTransactions,
    Join,
    Leave,
    RevertChain,
}

table SubmitTransactions {
    tx_root: Byte32,
    tx_count: Uint32,
    account_root_list: Byte32Vec,
}

// TODO
table Join {
}

table Leave {
}

// Revert the chain, send reward to reverter
struct RevertChain {
    reverter_id: Uint32,
    invalid_block_number: Uint64,
    post_account: MerkleState,
}

// --- end of define states ---

// --- contract execution ---

table KVPair { k: Byte32, v: Byte32, }
vector KVPairVec <KVPair>;

table CallContext {
    from_id: Uint32,
    to_id: Uint32,
    // 0: construct, 1: handle_message
    call_type: byte,
    args: Bytes,
}

struct BlockInfo {
    aggregator_id: Uint32,
    number: Uint32,
    timestamp: Uint64,
}

table VerificationContext {
    inputs: KVPairVec,
    changes: KVPairVec,
    block_info: BlockInfo,
    call_context: CallContext,
}

// --- end of contract execution ---
