import blockchain;

array Byte20 [byte; 20];
array Byte65 [byte; 65];

struct MerkleState {
    merkle_root: Byte32,
    count: Uint64,
}

table GlobalState {
    account: MerkleState,
    block: MerkleState,
    status: Status,
}

union Status {
    Running,
    Reverting,
}

// normal status
table Running {}
// layer2 chain is reverting
struct Reverting {
    next_block_number: Uint64,
    challenger_id: Uint32,
}

table Account {
    id: Uint32,
    pubkey_hash: Byte20,
    nonce: Uint32,
    script: ScriptOpt,
}

union Payment {
    Uint32,
    UDT,
}

struct UDT {
    type_hash: Byte32,
    value: Uint32,
}

table RawL2Transaction {
    from_id: Uint32,
    to_id: Uint32,
    nonce: Uint32,
    signature: Byte65,
    value: Payment,
    fee: Payment,
    args: Bytes,
}

table L2Transaction {
    raw: RawL2Transaction,
    signature: Byte65,
}

table RawL2Block {
    number: Uint64,
    aggregator_id: Uint32,
    prev_account: MerkleState,
    post_account: MerkleState,
    states: States,
    valid: byte,
}

table L2Block {
    raw: RawL2Block,
    signature: Byte65,
}

vector States <State>;

// --- define states ---

union State {
    SubmitTransactions,
    Join,
    Leave,
    RevertChain,
}

table SubmitTransactions {
    tx_root: Byte32,
    tx_count: Uint32,
    account_root_list: Byte32Vec,
}

// TODO
table Join {
}

table Leave {
}

// Revert the chain, send reward to reverter
struct RevertChain {
    reverter_id: Uint32,
    invalid_block_number: Uint64,
    post_account: MerkleState,
}

// --- end of define states ---
